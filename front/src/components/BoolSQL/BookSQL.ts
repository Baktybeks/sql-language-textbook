export const bookData = {
    id: 1,
    progress: 0,
    name: 'Понятие SQL',
    description: 'SQL — декларативный язык программирования, который используют для описания, изменения и извлечения информации в реляционных базах данных. Язык структурированных запросов популярен у программистов, разработчиков и администраторов баз данных. В этом обзоре собрали 6 книг, которые помогут на старте изучения SQL и при углублении в тему.',
    pages: [
        {
            chapterNumber: 1,
            pages: [
                { progress: 10,pageNumber: 1,description: '1-й час Добро пожаловать в мир SQL', content:
                        '\n' +
                        'Добро пожаловать в мир SQL и в обширный, но постоянно растущий мир бизнеса, основанного на использовании технологий баз данных. Прочитав эту книгу, вы получите знания, которые вскоре станут просто необходимыми для выживания в современном мире реляционных баз данных и управления ими. К сожалению, поскольку сначала необходимо разобраться с основами SQL и определить некоторые понятия, которые вам понадобятся в дальнейшем, этот урок представлен почти сплошным текстом. Смиритесь с этим, ведь приведенный здесь "скучный материал" непременно окупится сторицей.\n' +
                        '\n' +
                        'Основными на этом уроке будут следующие темы.\n' +
                        '\n' +
                        '• Введение в SQL и краткая история SQL\n' +
                        '\n' +
                        '• Введение в системы управления базами данных\n' +
                        '\n' +
                        '• Обзор основных терминов и понятий\n' +
                        '\n' +
                        '• Обзор базы данных, используемой в данной книге\n' +
                        '\n' +
                        'Определение и история SQL\n' +
                        'В любом бизнесе имеются данные, что в свою очередь требует создания некоторого организованного метода или механизма управления этими данными. Такой механизм принято называть системой управления базами данных (СУБД). Системы управления базами данных используются уже много лет, многие из них вышли из использовавшихся еще на мэйнфреймах систем плоских файлов. Основываясь на современных технологиях, доказавшие свою пользу системы управления базами данных начали развиваться в других направлениях, отвечая требованиям растущего бизнеса, все возрастающих объемов корпоративных данных и, конечно же, технологий, связанных с Internet.\n' +
                        '\n' +
                        'Современная волна информационных технологий управления основывается на использовании систем управления реляционными базами данных (СУРБД), которые являются развитием традиционных СУБД. Реляционные базы данных и технологии клиент/сервер являются типичной комбинацией, позволяющей современным компаниям успешно обрабатывать данные и оставаться конкурентоспособными в своих секторах рынка. В следующих разделах мы обсудим реляционные базы данных и технологию клиент/сервер подробнее, чтобы предоставить вам более прочную основу для использования стандартного языка реляционных баз данных - SQL.\n' +
                        '\n' +
                        'Что такое SQL?\n' +
                        'SQL - язык структурированных запросов - является стандартным языком управления реляционными базами данных. Его прототип был разработан фирмой IBM на основе идей, изложенных в статье д-ра Кодда (Е. F. Codd) "Реляционная модель данных для больших банков данных общего пользования". Немногим позже появления прототипа IBM, в 1979 году, на рынке появился первый продукт SQL под названием ORACLE, который был выпущен компанией Relational Software, Incorporated (впоследствии переименованной в Oracle Corporation). Сегодня эта компания является одним из выдающихся лидеров в области реализации технологий реляционных баз данных. SQL можно произносить либо по буквам - S-Q-L, либо как "сиквэл" (sequel) - оба произношения приемлемы.\n' +
                        '\n' +
                        'Когда вы отправляетесь в другую страну, вам может понадобиться язык той страны, в которую вы едете. Например, без знания языка у вас могут возникнуть трудности с заказом блюд из меню в ресторане, если окажется, что официант не понимает никаких других языков, кроме своего родного. Представляйте себе базу данных как чужую страну, в которой вам необходимо отыскать нужную информацию. Подобно заказу блюда из меню в ресторане другой страны, вы должны сформулировать свое требование нужной информации из базы данных в виде запроса, используя SQL.\n' +
                        '\n' +
                        'Что такое ANSI SQL?\n' +
                        'Американский национальный институт стандартов (ANSI) представляет собой организацию, которая устанавливает и внедряет стандарты в самых разных отраслях производства. SQL, ставший фактически стандартным языком в области управления базами данных, сначала был утвержден таковым в 1986 году на основе реализации IBM. В 1987 году стандарт ANSI SQL был принят в качестве международного стандарта Международной организацией стандартов (ISO). Этот стандарт был вновь пересмотрен в 1992 году и получил название SQL/92. Самый новый на сегодня стандарт называется SQL3 и иногда на него ссылаются как на SQL/99.\n' +
                        '\n' +
                        'Новый стандарт: SQL3\n' +
                        'SQL3 состоит из пяти взаимосвязанных документов и предполагается, что в ближайшем будущем к ним могут быть добавлено еще несколько. Вот эти пять взаимосвязанных частей стандарта.\n' +
                        '\n' +
                        '• Часть 1 - SQL/Структура (SQL/Framework) - определяет общие требования соответствия и фундаментальные понятия SQL.\n' +
                        '\n' +
                        '• Часть 2 - SQL/Основы (SQL/Foundation) - определяет синтаксис и операции SQL.\n' +
                        '\n' +
                        '• Часть 3 - SQL/Интерфейс вызовов (SQL/Call-Level Interface) - определяет интерфейс программного взаимодействия приложений с SQL.\n' +
                        '\n' +
                        '• Часть 4 - SQL/\'Встроенные модули (SQL/Persistent Stored Modules) - определяет управляющие структуры, лежащие в основе SQL-программ. Часть 4 определяет и модули, содержащие SQL-программы.\n' +
                        '\n' +
                        '• Часть 5 - SQL/Языковая привязка к серверу (SQL/Host Language Bindings) - определяет возможности встраивания операторов SQL в приложения, созданные на основе стандартных языков программирования.\n' +
                        '\n' +
                        'Этот новый стандарт ANSI (SQL3) позволяет использовать два минимальных уровня взаимодействия, которые может объявить СУБД - это поддержка ядра SQL (Core SQL Support) и поддержка расширенного SQL (Enhanced SQL Support).\n' +
                        '\n' +
                        'ANSI расшифровывается как American National Standards Institute (Американский Национальный институт стандартов). Этот институт представляет собой организацию, ответственную за внедрение стандартов на самые разные продукты и концепции.\n' +
                        '\n' +
                        'Каждый новый стандарт несет в себе не только множество преимуществ, но и некоторые неудобства. Прежде всего, стандарт направляет производителей по определенному руслу развития - в случае SQL, - обеспечивая базовый каркас из основных понятий, что в конце концов обеспечивает согласованность между различными реализациями и лучшую переносимость (не только для программ управления базами данных, но и для баз данных в целом, а также для тех людей, кто управляет базами данных).\n' +
                        '\n' +
                        'Некоторые возразят, что стандарт сам по себе не так уж и хорош, поскольку он ограничивает гибкость и потенциальные возможности каждой конкретной реализации. Но ведь большинство производителей, которые подчинились стандарту, добавили в свои реализации дополнительные по сравнению со стандартом SQL возможности, нивелирующие недостатки стандарта.\n' +
                        '\n' +
                        'В совокупности всех преимуществ и недостатков стандарт оказывается благом. Стандарт требует присутствия ряда возможностей во всякой полной реализации SQL и определяет базовые понятия, которые не только навязывают согласованность между всеми конкурирующими реализациями SQL, но и повышают ценность программистов, использующих SQL, и квалифицированных пользователей баз данных на современном рынке управления базами данных.\n' +
                        '\n' +
                        'Реализация SQL - это SQL-продукт конкретного производителя.\n' +
                        '\n' +
                        'Что такое база данных?\n' +
                        'Грубо говоря, база данных - это просто некоторая совокупность данных. Некоторые предпочитают представлять себе базу данных как некий организованный механизм, способный хранить информацию, посредством которого пользователь может эту информацию извлечь эффективным и полезным для себя образом.\n' +
                        '\n' +
                        'Люди используют базы данных ежедневно, даже не подозревая об этом. Например, базой данных оказывается телефонная книга. Содержащиеся в ней данные состоят из имен, адресов и телефонных номеров. Соответствующие списки либо упорядочены по алфавиту, либо индексированы, что позволяет пользователю без особых усилий найти нужного ему абонента Эти же данные хранятся где-то в виде базы данных и на компьютере. Ведь в конце концов страницы телефонной книги не перепечатываются каждый год вручную заново, когда выходит ее новое издание!\n' +
                        '\n' +
                        'Базу данных необходимо время от времени обновлять. В соответствии с переездами владельцев телефонов, записи в базу данных приходится добавлять или, наоборот, удалять из нее. Точно также необходимо вносить в базу данных изменения, когда люди меняют имена, адреса, телефонные номера и т. д. Пример структуры простой базы данных показан на рис. 1.1.' },
            ]
        },
        {
            chapterNumber: 2,
            progress: 50,
            description: 'Описание второй главы',
            pages: [
                {progress: 20, pageNumber: 2,description: 'Технология клиент/сервер', content: 'В прошлом компьютерная индустрия основывалась на использовании мэйнфреймов - больших и мощных компьютеров со значительными возможностями для хранения и обработки данных. Пользователи имели возможность общения с мэйнфреймами посредством "тупых" терминалов. Эти терминалы не имели своих собственных "интеллектуальных" возможностей и полагались исключительно на вычислительные возможности, память и носители информации мэйнфрейма. Каждый терминал имел свою линию обмена данными с мэйнфреймом. Оборудование мэйнфреймов вполне справлялось со своими задачами и соответствовало требованиям бизнеса того времени, но пришло время для новой, значительно более прогрессивной технологии - модели клиент/сервер.\n' +
                        '\n' +
                        'В системе клиент/сервер главный компьютер, называемый сервером, обычно доступен через сеть, как правило, это локальная сеть (LAN - Local area network) или глобальная сеть (WAN - Wide area network). Доступ к такому серверу теперь обеспечивается не посредством "тупых" терминалов, а персональных компьютеров (ПК) или других серверов. В этом случае персональный компьютер называется клиентом и должен иметь доступ к сети, чтобы между клиентом и сервером имелась возможность обмена данными. Главное различие между системой клиент/сервер и системой, основанной на использовании мэйнфрейма, заключается в том, что пользователь ПК в системе клиент/сервер может использовать вычислительные возможности своего собственного компьютера для обработки данных и выполнения других процессов непосредственно в памяти своего компьютера, но в то же время и сервер оказывается всегда доступным для пользователя через сеть. На сегодня в большинстве случаев система клиент/сервер удовлетворяет всем требованиям современного бизнеса, оказывается более гибкой и в конце концов более предпочтительной.\n' +
                        '\n' +
                        'Реляционные базы данных размещаются как на мэйнфреймах, так и на платформах клиент/сервер. Хотя система клиент/сервер и более предпочтительна, для многих компаний по различным причинам оказывается все еще оправданным использование мэйнфреймов. Но достаточно высок процент тех компаний, которые в последнее время оставили свои мэйнфреймы в прошлом и перевели все свои данные на платформу клиент/сервер, чтобы не остаться в стороне от современных технологий, обеспечить себе и своему бизнесу большую гибкость, а своим системам - независимость от проблемы 2000 года.\n' +
                        '\n' +
                        '\n' +
                        '\n' +
                        'Рис. 1.3. Модель клиент/сервер\n' +
                        '\n' +
                        'Для одних компаний переход на использование технологии клиент/сервер оказался оправданным, для других же внедрение этой технологии обернулось неудачей и, как следствие, выброшенными на ветер миллионами долларов. В результате некоторым пришлось даже вернуться к своим старым мэйнфреймам, поэтому не все решаются проводить такие потенциально опасные изменения. Причиной таких неудач являются недостаточно тщательная экспертиза необходимости изменений - следствие новизны технологии в совокупности с недостаточной квалификацией персонала в соответствующей области деятельности. Тем не менее понимание технологии клиент/сервер является необходимым в свете растущих (и иногда неадекватно высоких) требований современного бизнеса и развития технологий Internet и компьютерных сетей. Технология клиент/сервер показана на рис. 1.3.\n' +
                        '\n' +
                        'Популярные производители систем управления базами данных\n' +
                        'Среди доминирующих производителей систем управления базами данных следует назвать Oracle, Microsoft, Informix, Sybase и IBM. И хотя в мире существует их значительно больше, именно представленные здесь имена вы чаще всего встречаете в книгах, газетах, журналах и в World Wide Web.\n' +
                        '\n' +
                        'Различия между реализациями\n' +
                        'Так же как человек, имеющий только ему присущие индивидуальные черты, конкретные реализации SQL разных производителей имеют определенные особенности. Серверы базы данных, подобно любому другому продукту на рынке, изготавливаются широким спектром производителей. Соответствие производимой реализации текущему стандарту ANSI в целях совместимости и удобства пользователя остается на совести самого производителя. Например, при переходе компании от одного сервера баз данных к другому, большим неудобством для пользователей оказалась бы необходимость изучения нового языка, с помощью которого приходится осуществлять поддержку новой системы.\n' +
                        '\n' +
                        'В каждой реализации SQL производители предлагают различные усовершенствования с целью упрощения работы с производимыми ими серверами баз данных. Эти усовершенствования или, расширения, представляют собой команды и опции, предлагаемые в дополнение к стандартному набору команд SQL и доступные в рамках каждой конкретной реализации.\n' +
                        '\n' +
                        'Сеанс SQL\n' +
                        'Сеанс SQL - это период взаимодействия пользователя с реляционной базой данных посредством использования команд SQL. Начинается сеанс с момента подключения пользователя к базе данных. В рамках сеанса пользователь имеет возможность вводить допустимые команды SQL для осуществления запросов, управления данными, создания новых структур базы данных (например, таблиц).\n' +
                        '\n' +
                        'Команда CONNECT\n' +
                        'Сеанс SQL начинается в момент подключения пользователя к базе данных. Для этого используется команда CONNECT. С помощью команды CONNECT можно либо осуществлять подключения к базе данных, либо менять характер уже установленных подключений. Например, подключившись к базе данных под именем USER1, вы можете затем использовать команду CONNECT, чтобы подключиться к той же базе данных под именем USER2. При этом неявно прекращается сеанс SQL для пользователя USER1.\n' +
                        '\n' +
                        'CONNECT user@database\n' +
                        '\n' +
                        'При попытке подключиться к базе данных вы автоматически получите запрос на введение пароля, соответствующего введенному вами имени пользователя.\n' +
                        '\n' +
                        'Команда DISCONNECT\n' +
                        'Сеанс SQL прекращается при отключении пользователя от базы данных. Для отключения пользователя от базы данных используется команда DISCONNECT. После отключения от базы данных вы еще можете пользоваться программными средствами связи с базой данных, но сама связь с базой данных будет прекращена. При использовании для разрыва связи оператора EXIT прекращается не только ваш сеанс SQL, но и закрывается программа, с помощью которой осуществлялся доступ к базе данных.\n' +
                        '\n' +
                        'DISCONNECT\n' +
                        '\n' +
                        'Типы команд SQL\n' +
                        'В следующих разделах мы обсудим основные категории команд, реализующих в SQL выполнение различных функций. Среди таких функций - построение объектов базы данных, управление объектами, пополнение таблиц базы данных новыми данными, обновление данных, уже имеющихся в таблицах, выполнение запросов, управление доступом пользователей к базе данных, а также осуществление общего администрирования базы данных.' }
            ]
        },
        {
            chapterNumber: 3,
            progress: 50,
            pages: [
                {progress: 30, pageNumber: 3,description: 'Определение структур базы данных (DDL)', content: 'Язык определения данных (DDL) является частью SQL, дающей пользователю возможность создавать различные объекты базы данных и переопределять их структуру, например, создавать или удалять таблицы.\n' +
                        '\n' +
                        'Среди основных команд DDL, которые мы предполагаем с вами обсудить в дальнейшем, будут следующие команды.\n' +
                        '\n' +
                        'CREATE TABLE\n' +
                        '\n' +
                        'ALTER TABLE\n' +
                        '\n' +
                        'DROP TABLE\n' +
                        '\n' +
                        'CREATE INDEX\n' +
                        '\n' +
                        'ALTER INDEX\n' +
                        '\n' +
                        'DROP INDEX\n' +
                        '\n' +
                        'Эти команды будут подробно обсуждаться в ходе урока 3, "Управление объектами базы данных", и урока 17, "Повышение эффективности работы с базой данных".\n' +
                        '\n' +
                        'Манипуляция данными (DML)\n' +
                        'Язык манипуляций данными (DML) является частью SQL, дающей пользователю возможность манипулировать данными внутри объектов реляционной базы данных.\n' +
                        '\n' +
                        'Вот три основные команды DML:\n' +
                        '\n' +
                        'INSERT\n' +
                        '\n' +
                        'UPDATE\n' +
                        '\n' +
                        'DELETE\n' +
                        '\n' +
                        'Эти команды будут обсуждаться подробно в ходе урока 5, "Манипуляция данными".\n' +
                        '\n' +
                        'Отбор данных (DQL)\n' +
                        'Хотя этот раздел языка представлен только одной командой, для пользователя реляционной базы данных язык запросов к данным (DQL) является самой главной частью SQL. Этой командой является команда\n' +
                        '\n' +
                        'SELECT\n' +
                        '\n' +
                        'Эта команда, имеющая множество опций и необязательных параметров, используется для построения запросов к реляционным базам данных. С ее помощью можно конструировать запросы любой сложности - от самых общих до очень специальных и от самых простых до невероятно сложных. Команда SELECT будет подробно обсуждаться в ходе уроков 7-16.\n' +
                        '\n' +
                        'Запрос - это требование на получение информации из базы данных.\n' +
                        '\n' +
                        'Язык управления данными (DCL)\n' +
                        'Команды управления данными в SQL позволяют осуществлять контроль над возможностью доступа к данным внутри базы данных. Команды DCL обычно используются для создания объектов, относящихся к управлению доступом пользователей к базе данных, а также для назначения пользователям подходящих уровней привилегий доступа. Вот некоторые из команд управления данными:\n' +
                        '\n' +
                        'ALTER PASSWORD\n' +
                        '\n' +
                        'GRANT\n' +
                        '\n' +
                        'REVOKE\n' +
                        '\n' +
                        'CREATE SYNONYM\n' +
                        '\n' +
                        'Эти команды часто используются вместе с другими командами и поэтому будут появляться во многих последующих главах книги.\n' +
                        '\n' +
                        'Команды администрирования данных\n' +
                        'Команды администрирования данных дают пользователю возможность выполнять аудит и анализ операций внутри базы данных. Эти команды могут также помочь при анализе производительности системы данных в целом. Вот две команды администрирования данных общего вида:\n' +
                        '\n' +
                        'START AUDIT\n' +
                        '\n' +
                        'STOP AUDIT\n' +
                        '\n' +
                        'He путайте администрирование данных с администрированием всей базы данных. Администрирование базы данных - это осуществление общего управления базой данных, предполагающее возможность использования команд любого уровня.\n' +
                        '\n' +
                        'Команды управления транзакциями\n' +
                        'В дополнение ко всем уже рассмотренным категориям команд есть еще команды, позволяющие пользователю управлять транзакциями базы данных.\n' +
                        '\n' +
                        '• Команда COMMIT используется для того, чтобы сохранить транзакции.\n' +
                        '\n' +
                        '• Команда ROLLBACK используется для того, чтобы отменить транзакции.\n' +
                        '\n' +
                        '• Команда SAVEPOINT создает точки внутри групп транзакций, к которым отсылает команда ROLLBACK.\n' +
                        '\n' +
                        '• Команда SET TRANSACTION позволяет назначить транзакции имя.\n' +
                        '\n' +
                        'Команды управления транзакциями будут подробно обсуждаться в ходе урока 6. "Управление транзакциями".\n' +
                        '\n' +
                        'Описание базы данных, используемой в данной книге\n' +
                        'Прежде чем продолжить наше с вами путешествие в мир SQL, давайте определим те таблицы и данные, которые мы будем использовать в инструкциях всех следующих уроков. Следующие два раздела представляют собой обзор всех таблиц этой конкретной базы данных, их структуры, связей и содержащихся в них данных.\n' +
                        '\n' +
                        'Схема таблиц, используемых в книге\n' +
                        'На рис. 1.4 показаны отношения между таблицами, используемыми в этой книге для примеров, вопросов для проверки и упражнений. Каждая из таблиц имеет скос имя, точно так же свои имена назначены в таблицах каждому из полей. Линии, связывающие таблицы, указывают на связи таблиц посредством общего поля, которое в большинстве случаев называется ключевым полем (последние обсуждаются в ходе урока 3, "Управление объектами базы данных").\n' +
                        '\n' +
                        'Стандарты назначения имен таблицам\n' +
                        'Стандарты назначения имен таблицам, как и любые стандарты в бизнесе вообще, очень важны с точки зрения осуществления контроля. Проанализировав таблицы и данные из предыдущих разделов, вы, наверное, заметили, что все имена таблиц имели суффикс _TBL. Наличие такого суффикса в именах таблиц принято за стандарт. В этом случае _TBL просто говорит о том, что соответствующий объект является таблицей - ведь в базе данных может содержаться и множество других объектов. Например, вы увидите, что суффикс _IDX используется для индексов таблиц. Стандарты назначения имен вводятся почти исключительно в целях упрощения общей организации и Оказываются очень полезными в деле администрирования любой реляционной базы данных. Вместе с тем, использование суффиксов при назначении имен объектам базы дйнных не является строго обязательным.\n' +
                        '\n' +
                        'Желательно не только следовать предлагаемым конкретной реализацией SQL правилам назначения имен, но и правилам, принятым внутри соответствующей области деятельности, чтобы имена носили описательный характер и соответствовали тем данным, на которые эти имена указывают.\n' +
                        '\n' +
                        '\n' +
                        '\n' +
                        'Рис. 1.4. Связи между таблицами, используемыми в этой книге\n' +
                        '\n' +
                        'Обзор данных\n' +
                        'В этом разделе приводится обзор данных, содержащихся в таблицах, используемых в книге. Потратьте несколько минут на то, чтобы просмотреть эти данные и разобраться в связях как между таблицами, так и между непосредственно данными. Обратите внимание на то, что некоторые поля не требуют обязательного наличия в них данных - такая возможность должна быть задана при создании таблицы в базе данных.' }
            ]
        },
        {
            chapterNumber: 4,
            progress: 50,
            pages: [
                {progress: 40, pageNumber: 4,description: 'Реляционные базы данных – проще некуда', content: 'Я не буду сразу же нырять в сложные вещи и дам только необходимую информацию о базах данных, чтобы мы перешли к языку запросов SQL и начали уже на практике пробовать и смотреть на результат. Я не буду затрагивать вопросы администрирования, потому что мы рассмотрим теорию только то, что необходимо программистам.\n' +
                        '\n' +
                        'Существуют различные базы данных, и они могут решать различные задачи, но самой популярной уже много лет назад стала реляционная база, которая в простом виде выглядит как простые двумерные таблицы, которые связаны между собой. Сразу же скажу, что это не является определением реляционной базы данных, а просто объяснением, чем они являются. В Википедии можно найти более умное и настоящее определение, которое придумали много лет назад,но суть останется та же, мы будем работать с таблицами.\n' +
                        '\n' +
                        'Почему именно это модель стала популярной и существует все эти годы несмотря на то, что вокруг многое уже поменялось? Дело в том, что данные проще всего представить именно таблицей. Практически любые данные можно записать в таблице Microsoft Excel или Google Sheets – две самые популярные программы для работы с данными.\n' +
                        '\n' +
                        'Классическая задача телефонный справочник - это таблица из столбцов и строк:\n' +
                        '\n' +
                        'Имя\tТелефон\tГород\n' +
                        'Алексей Петров\t+71234567\tToronto\n' +
                        'Сергей Иванов\t+75491631\tToronto\n' +
                        'Анна\t+72726260\tNew York\n' +
                        'Вадим\t+76272861\tNew York\n' +
                        'Елена\t+71019742\tNew York\n' +
                        'У колонки есть имя, которое указывает, что именно находиться в данной колонки каждой строки. Ну а в строках сами данные.\n' +
                        '\n' +
                        'В данном случае у нас есть одна проблема, которая может в реальной жизни стать большой. Как найти номер телефона по фамилии? У нас имя и фамилия в одной колонке и. . . Как отделить имя и фамилию? Имя может состоять из двух слов, бывают в наше время такие имена. Фамилия тоже может быть из двух слов, такое тоже бывает. Так что если будет написано Алексей Немирович Данченко – где имя, а где фамилия?\n' +
                        '\n' +
                        'Чтобы не столкнуться с такой проблемой никогда не храните данные, которые можно разделить в одной колонке.\n' +
                        '\n' +
                        'Имя\tФамилия\tТелефон\tГород\n' +
                        'Алексей\t+Петров\t+71234567\tToronto\n' +
                        'Домашний адрес – для него создаем отдельную колонку для каждой составляющей – квартира, улица, дом, индекс – все это должно быть отдельные колонки. Никогда не пытайтесь объединить все в одну строку.\n' +
                        '\n' +
                        'Дальше я фамилию опущу, чтобы проще было представлять данные.\n' +
                        '\n' +
                        'В реальной жизни строк будет конечно же больше в телефонном справочнике и может быть на много больше колонок, но смысл остаётся тем же, мы их записываем в таблицу.\n' +
                        '\n' +
                        'Там, где одна таблица не способна решить задачу можно создать несколько таблиц. Причиной для создания нескольких таблиц может быть и нормализация. В википедии можно найти умное определение нормализации данных, а если упростить определение до максимума, то это избавление от избыточности данных.\n' +
                        '\n' +
                        'С помощью нормализации можно значительно сократить размер базы данных и избавиться от повторяющихся данных.\n' +
                        '\n' +
                        'Посмотрите на таблицу телефонного справочника. Имена обычно достаточно уникальные данные. Телефонный номер скорей всего будет уникальный в наше время. Да, одним номером стационарного телефона пользуется целая семья, а в коммунальной квартире может быть даже две семьи, но в целом номер обычно зарегистрирован за одним человеком, так что тут повторений не будет.\n' +
                        '\n' +
                        'А вот если мы посмотрим на последнюю колонку, то тут у нас город и в реальной жизни в телефонном справочнике может быть миллион и даже несколько миллионов записей с одним и тем же названием города. Казалось бы, в чем проблема, ну храним мы миллион раз слово Санкт-Петербург и что?\n' +
                        '\n' +
                        'Дело в том, что в зависимости от того, какой вариант кодирования строки вы выбрали для хранения символов название города Санкт-Петербург может занимать от 15 байт до достаточно большого количества байт.\n' +
                        '\n' +
                        'Есть тип данных char и если сказать, что максимальный размер названия города 50 символов, то база данных всегда будет выделять 50 символов на диске умноженное на размерность одного символа. В Unicode каждый символ может занимать два байта, хотя бывают различные Unicode кодировки, упростим простым вариантом в два байта.\n' +
                        '\n' +
                        'Возможно, какие-то базы будут выделять только реально необходимое количество символов, но по задумке должно быть всегда 50 символов * 2 байта. И это очень много. Миллион записей с телефонными номерами обернуться в 100 миллионов байт на диске, а это ПОЧТИ 100 мегабайт только для хранения города – одной колонки. Это очень много и это как раз и есть избыточность.\n' +
                        '\n' +
                        'Даже если использовать varchar, который должен выделять на диске только нужное количество символов, 15 символом умножить на размерность символа 2 байта, получается 30 миллионов байт на миллион записей или 30 мегабайт. Да, экономия приличная, но все же информация остается избыточной.\n' +
                        '\n' +
                        'А если создать отдельный справочник городов, который будет состоять из двух колонок в таблице – число (номер города) и название города:\n' +
                        '\n' +
                        'Номер города\tНазвание города\n' +
                        '1\tToronto\n' +
                        '2\tNew York\n' +
                        '3\tParis\n' +
                        'При таком раскладе наша таблица телефонного справочника может выглядеть так:\n' +
                        '\n' +
                        'Имя\tТелефон\tГород\n' +
                        'Алексей\t+71234567\t1\n' +
                        'Сергей\t+75491631\t1\n' +
                        'Анна\t+72726260\t2\n' +
                        'Вадим\t+76272861\t2\n' +
                        'Елена\t+71019742\t2\n' +
                        'Теперь вместо хранения целого названия города мы храним только его номер и согласно справочнику городов 1 это Toronto, а 2 это New York.\n' +
                        '\n' +
                        'Сколько в таком случае понадобиться памяти для хранения информации в колонке город? Если выбрать число из 2 байтов, то мы сможем закодировать чуть более 65 тысяч городов. Если выбрать число из 4 байт, то уже более 2 миллиардов (а если без знака, то все 4, но это уже отдельный вопрос) и этого будет с головой для хранения всех городов всей планеты. Я так думаю. На земле же меньше 2 миллиардов городов?\n' +
                        '\n' +
                        'Итак, берем 4 байта и умножаем на количество записей и получаем около 4 мегабайт. Да, у нас есть еще одна запись в справочнике городов, где храниться само имя города, но вся запись там занимает 4 байта на хранения цифры (номера или идентификатора города) + 30 символов на хранение имени. Это мелочи.\n' +
                        '\n' +
                        'Таким образом со 100 мегабайт мы опустились сначала до 30, а теперь и вовсе до 4. И это плюс не только с точки зрения хранения данных на диске, но и с точки зрения работы с данными. Допустим, что нужно найти какой-то телефон в базе и программа должна пробежать по каждой записи и найти нужную. В случае с таблицей размеров в 100 мегабайт придется прочитать с диска всю эту информацию с целью сравнить каждый номер. Есть способы оптимизации этого процесса, но допустим, что у нас сейчас нет возможности и мы обязаны просканировать все данные в таблице. Просто даже прочитать 100 мегабайт с диска – это на много дольше, чем прочитать с диска 4 мегабайта, а точнее в 25 раз дольше.\n' +
                        '\n' +
                        'Так что избыточность – это плохо не только с точки зрения хранения информации, но и с точки зрения ее использования.\n' +
                        '\n' +
                        'Итак, у нас теперь для описания телефонного справочника есть две таблицы, каждая из которых является необходимой, и они связаны. Для хранения таблицы телефонов нам нужна таблица городов и именно та, с помощью которой мы кодировали города. Если взять другую таблицу, то там под номером 1 может быть Киев или Минск и тогда телефонный справочник будет испорченным, будут другие города. Очень важно хранить таблицы вместе в одном хранилище, и они должны быть связанными.\n' +
                        '\n' +
                        'Хранилище для таблиц как раз и называется базой данных. Если в хранилище находятся таблицы со связанными, как мы рассмотрели выше, то такая база данных становится реляционной. Или если сказать по-другому, реляционная база данных предназначена для хранения таблица со связями и база данных обычно предоставляет средства, которые позволяют управлять и поддерживать эти связи между справочниками городов и основной таблицей номеров телефонов.\n' +
                        '\n' +
                        'Чаще всего каждая программа или сайт работает только с одной базой данных, так сказать одна база на одно приложение, но бывают случаи, когда приходиться работать сразу с несколькими.\n' +
                        '\n' +
                        'Рассмотрим еще пример. А что если у нас есть пол:\n' +
                        '\n' +
                        'Имя\tТелефон\tГород\tПол\n' +
                        'Алексей\t+71234567\t1\tМ\n' +
                        'Сергей\t+75491631\t1\tМ\n' +
                        'Анна\t+72726260\t2\tЖ\n' +
                        'Вадим\t+76272861\t2\tМ\n' +
                        'Елена\t+71019742\t2\tЖ\n' +
                        'Для хранения пола нам достаточно одного символа М или Ж. В Канаде уже можно увидеть больше вариантов, но все равно, их кажется не больше 5, что также можно обозначить все еще одной буквой.\n' +
                        '\n' +
                        'В зависимости от кодировки один символ будет занимать в памяти 1 байт и более. Самая популярная Unicode в среднем занимает 2 байта. То есть для хранения поля с полом в одной строке нужно два байта.\n' +
                        '\n' +
                        'Можно создать справочник для пола:\n' +
                        '\n' +
                        'Номер Пола\tПол\n' +
                        '1\tМ\n' +
                        '2\tЖ\n' +
                        'Выиграем мы от этого или нет? Для хранения номера можно выделить число размером в один байт и получиться, чтобы сможем адресовать 256 различных вариантов полов, что должно хватить на ближайшие лет 100, я надеюсь.\n' +
                        '\n' +
                        'В данном случае экономия не такая уж и большая, чтобы создавать отдельную таблицу со справочником полов.\n' +
                        '\n' +
                        'Но что, если у нас есть какая-то колонка, в которой в виде одного символа храниться какой-то код.\n' +
                        '\n' +
                        'Имя\tТелефон\tГород\tКод\n' +
                        'Алексей\t+71234567\t1\tА\n' +
                        'Сергей\t+75491631\t1\tА\n' +
                        'Анна\t+72726260\t2\tЮ\n' +
                        'Вадим\t+76272861\t2\tБ\n' +
                        'Елена\t+71019742\t2\tБ\n' +
                        'И вдруг кто-то пришел и сказал, а давайте поменяем коды с русских букв на английские. Если в таблице 1,000,000 записей, то придется найти каждую из них и изменить код с русской буквы А на английскую, с русской буквы Б на английскую B. Миллион записей превратиться в миллион обновлений.\n' +
                        '\n' +
                        'Если пол так массово скорей всего не будет меняться и для него создавать отдельную таблицу не эффективно и не выгодно, то вот какая-то колонка с кодами может поменяться. Если мы вынесем коды в отдельную таблицу и будем использовать ее как справочник:\n' +
                        '\n' +
                        'Имя\tТелефон\tГород\tКод\n' +
                        'Алексей\t+71234567\t1\t1\n' +
                        'Сергей\t+75491631\t1\t1\n' +
                        'Анна\t+72726260\t2\t2\n' +
                        'Вадим\t+76272861\t2\t3\n' +
                        'Елена\t+71019742\t2\t3\n' +
                        'Таблица кодов:\n' +
                        '\n' +
                        'Номер Пола\tКод\n' +
                        '1\tА\n' +
                        '2\tЮ\n' +
                        '3\tБ\n' +
                        'То в случае необходимости заменить коды букв с русские на английские нам нужно будет поменять только справочник. Сменить только в таблице кодов русскую А на английскую А и все, все записи в основной таблице уже указывают на английскую букву. Крутатень, да и только.\n' +
                        '\n' +
                        'Такие вещи называют нормальизацией, когда мы избавляемся от избыточности о обеспечиваем более эффективный метод сопровождения базы.\n' +
                        '\n' +
                        'С теорией разобрались, пока переходить к практике. Я буду работать с базой данных на примере MySQL – бесплатная база данных, которая сейчас принадлежит Oracle. Она одна из самых популярных и устанавливается по умолчанию на большинстве хостингов в интернете. Это идеальное решение для небольших проектов и сайтов.' }
            ]
        },
        {
            chapterNumber: 5,
            progress: 50,
            pages: [
                {progress: 50, pageNumber: 5,description: 'Работаем с SQL – выборка данных', content: 'Самым популярным способом доступа к реляционным базам данных является язык запросов SQL. Именно с ним мы и будем знакомиться в этой главе. Мне кажется, проще всего начинать знакомство с доступа к данным, потому что это самый важный и часто используемый компонент и знание, которое необходимо программистам и тестерам.\n' +
                        '\n' +
                        'Для те, кто знает и тем более говорит на английском язык запросов будет прост, потому что построение команд по своей структуре похоже, как мы строим предложения, чтобы попросить голосовой помощник сделать что-то.\n' +
                        '\n' +
                        'Для тестирования нам понадобиться какая-то база данных, на которой мы будем тренироваться. Так как создание самой базы и таблиц я решил отложить на потом, я подготовил файл, который создаст для вас две таблицы.\n' +
                        '\n' +
                        'Phone:\n' +
                        '\n' +
                        'Phoneid\tFirstname\tLastname\tPhone\tCityid\n' +
                        '1\tJohn\tDoe\t4144122\t1\n' +
                        '2\tSteve\tDoe\t414124\t1\n' +
                        '3\tJohnatan\tSomething\t4142947\t2\n' +
                        '4\tDonald\tTrump\t414251123\t2\n' +
                        '5\tAlice\tCooper\t414254234\t2\n' +
                        '6\tMichael\tJackson\t4142544\t3\n' +
                        '7\tJohn\tAbama\t414254422\t3\n' +
                        '8\tAndre\tJackson\t414254422\t3\n' +
                        '9\tMark\tOh\t414254422\t \n' +
                        '10\tCharly\tLownoise\t414254422\t \n' +
                        'City\n' +
                        '\n' +
                        'Cityid\tcityname\n' +
                        '1\tToronto\n' +
                        '2\tVancouver\n' +
                        '3\tMontreal\n' +
                        'Итак, скачайте файл testdb.sql\n' +
                        '\n' +
                        'Если вы используете VS Code, то подключитесь к базе данных mysql, откройте новое окно для SQL запросов, скопируйте в него содержимое файла testdb.sql, и нажмите кнопку выполнения.\n' +
                        '\n' +
                        'Если вы используете командную строку, то подключитесь к базе данных, скопируйте содержимое файла testdb.sql в буфер обмена и теперь кликните правой кнопкой в окне терминала. Команды из файла должны вставиться и выполниться в терминале. Выполняться все, кроме последней, вам скорей всего придется нажать Enter, чтобы завершить последнюю команду.\n' +
                        '\n' +
                        'Теперь мы готовы к изучению SQL. Когда вы работаете с Excel таблицей, что вы можете с ней сделать? Искать данные в таблице поиском, добавлять новые строки, изменять существующие, удалять строки. То же самое можно делать и с базой данных, давайте начнем знакомиться с тем, как можно отображать содержимое таблицы и искать данные.\n' +
                        '\n' +
                        'SELECT доступ к одной таблице\n' +
                        'Команда SELECT достаточно простая, потому что она выглядит и звучит вполне логично и последовательно. Да, она может быть и сложной, потому что позволяет достаточно многое, и чтобы не пугать вас, я даже не буду пытаться показывать сейчас максимальную версию.\n' +
                        '\n' +
                        'Начнем с самой простой версии:\n' +
                        '\n' +
                        'SELECT колонки FROM базаданных.таблица\n' +
                        'Большими буквами я выделил ключевые слова языка запросов SQL, а русскими маленькими буквами показано то, что мы должны заменить на реальные значения. Если перевести эту команду, то она будет звучать:\n' +
                        '\n' +
                        'ВЫБРАТЬ колонки ИЗ база.данных.таблица\n' +
                        'Если исправить склонение в последнем слове, то все будет звучать совсем ясно и понятно.\n' +
                        '\n' +
                        'Колонки – это список имен колонок через запятую. Если вы хотите выбрать все колонки, то можно указать символ звездочки *.\n' +
                        '\n' +
                        'У нас есть таблица City, давайте выберем из нее все записи и все колонки. Все колонки, значит нужно заменить слово "колонки" на символ звездочки, а на месте таблицы пишем city и в результате получаем\n' +
                        '\n' +
                        'SELECT * FROM testdb.сity\n' +
                        'Не забываем, что если выполнять из командной строки в mysql, то нужно в конце добавить точку запятой, но очень часто она не нужна, поэтому я в своих запросах буду опускать этот символ.\n' +
                        '\n' +
                        'В результате мы должны увидеть следующее:\n' +
                        '\n' +
                        '+--------+-----------+\n' +
                        '| cityid | cityname  |\n' +
                        '+--------+-----------+\n' +
                        '|      1 | Toronto   |\n' +
                        '|      2 | Vancouver |\n' +
                        '|      3 | Montreal  |\n' +
                        '+--------+-----------+\n' +
                        '3 rows in set (0.00 sec)\n' +
                        'Если мы пишем множество запросов, неужели каждый раз придется писать имя базы данных перед именем таблицы? Нет, это не обязательно. Если вы работаете с определенной базой, то можно как бы перейти в нее, или можно еще сказать выбрать ее. Для этого выполняем команду:\n' +
                        '\n' +
                        'USE базаданных\n' +
                        'Слово USE означает «использовать». То есть мы просим сервер использовать определенную базу для всех последующих запросов, пока снова не выберем другую. В нашем случае база данных это testdb, так что выполняем команду:\n' +
                        '\n' +
                        'USE testdb\n' +
                        'Теперь имя базы перед именем таблицы указывать не нужно, а значит запрос на получения всех колонок и всех строк из таблицы city может выглядеть теперь так:\n' +
                        '\n' +
                        'SELECT * FROM сity\n' +
                        'Это достаточно важный пункт, поэтому не забывайте его. В дальнейшем я буду писать запросы с учетом, что текущая база данных это testdb и поэтому перед именем таблицы указывать имя базы не буду.\n' +
                        '\n' +
                        'В зависимости от настроек и используемой базы данных имена SQL может быть чувствительным к регистру и нет. Все чаще сталкиваюсь с тем, что MySQL по умолчанию ставится чувствительным к регистру, а значит имя таблицы нужно указать именно так, как это было при создании. Чтобы было проще, я все имена давал в нижем регистре.\n' +
                        '\n' +
                        'Это значит, что следующие две команды могут завершиться ошибкой:\n' +
                        '\n' +
                        'SELECT * FROM City\n' +
                        'SELECT * FROM CITY\n' +
                        'Потому что называние города написано в неверном регистре.\n' +
                        '\n' +
                        'Писать команды SQL большими буквами не обязательно. Вот их как раз можно писать в любом регистре и следующая команда завершиться удачно:\n' +
                        '\n' +
                        'select * from city \n' +
                        'Или даже эта\n' +
                        '\n' +
                        'SeLeCt * FrOm city\n' +
                        'Я не помню уже почему, то много лет назад, еще в 90-е годы я привык писать все слова, которые относятся к SQL большими буквами, чтобы они выделялись. На мой взгляд это читается проще, но вы не обязаны следовать этому же подходу.\n' +
                        '\n' +
                        'Если в качестве колонок указать звездочку, то отображаются все поля в том порядке, в котором они создавались в базе данных. Мы можем перечислить имена через запятую:\n' +
                        '\n' +
                        'SELECT cityid, cityname FROM city\n' +
                        'В этом случае у нас есть возможность указать имена в любом порядке и указать сначала имя города, а потом идентификатор:\n' +
                        '\n' +
                        'SELECT cityname, cityid FROM city\n' +
                        'Или можно отобразить только имя города:\n' +
                        '\n' +
                        'SELECT cityname FROM city\n' +
                        'Настоятельно рекомендую повторять все, что мы здесь рассматриваем, потому что именно практика позволяет лучше запомнить материал.\n' +
                        '\n' +
                        'Пробелы в именах объектов базы данных\n' +
                        'У тебя может возникнуть вопрос – а что, а можно создавать имена таблица или колонок из нескольких слов и как тогда MySQL будет работать с пробелами? Создавать объекты с пробелами можно, но в этом случае имя нужно окружить специальными символами, которые зависят от базы данных, в MySQL это символ ` который находится слева от цифры 1 на большинстве клавиш.\n' +
                        '\n' +
                        'Так что теоретически наш запрос может выглядеть так:\n' +
                        '\n' +
                        'SELECT `Adress id`, Name FROM `Address Table`\n' +
                        'Обратите внимание, что колонка Address id содержит пробел, поэтому вначале и в конце стоит символ `. У колонки Name нет пробелов, поэтому ничего добавлять не нужно. У имени таблицы так же есть пробел.\n' +
                        '\n' +
                        'Если в имени объекта есть пробел, то ` является обязательным, если пробела нет, то можно поставить, а можно и опустить. Это значит, следующие запросы одинаково корректны:\n' +
                        '\n' +
                        'SELECT `cityname` FROM `city`;\n' +
                        'SELECT cityname FROM `city`;\n' +
                        'SELECT `cityname` FROM city;\n' +
                        'SELECT cityname FROM city;\n' +
                        'Все они корректны и все будут работать.\n' +
                        '\n' +
                        'Хотя все примеры мы рассматриваем и тестируем под MySQL, почти все они будут работать и в других базах данных, но вот разделитель в разных базах может отличаться. В MS SQL Server это квадратные скобки:\n' +
                        '\n' +
                        'SELECT [cityname] FROM [city];\n' +
                        'Очень часто программисты стараются создавать таблицы и колонки без пробелов, поэтому не так часто можно увидеть запросы, в которых используются символы, которыми окружаются имена объектов.\n' +
                        '\n' +
                        'Фильтрация выборки WHERE\n' +
                        'Отлично, мы научились выбирать все данные из таблицы или определенные колонки, а теперь хорошо бы научиться еще и выбирать только определенные строки.\n' +
                        '\n' +
                        'Формат команды выборки начинает усложняться и уже начинает выглядеть так:\n' +
                        '\n' +
                        'ВЫБРАТЬ колонки ИЗ таблица ГДЕ фильтр\n' +
                        'В качестве фильтра можно указывать имя колонки, по которой мы хотим фильтровать и значение, которое мы ищем. Например, если мы хотим найти все записи из нашего телефонного справочника, где фамилия владельца это Doe, то мы должны в фильтре указать:\n' +
                        '\n' +
                        'lastname = \'Doe\'\n' +
                        'Здесь lastname – это имя колонки, поэтому его просто указываем без каких-то дополнений. Когда сервер будет читать этот запрос, то он увидит слово lastname, попробует найти это имя среди известных ему имен и без проблем сможет найти его, так что вопросов нет.\n' +
                        '\n' +
                        'Фамилия – это строка, которая неизвестна MySQL. Для него это просто текст, и он не уверен, где начинается строка и заканчивается. Чтобы проще было определить начало и конец произвольных строк, мы должны помещать их в одинарные кавычки, как в примере выше.\n' +
                        '\n' +
                        'Взглянем на следующий пример:\n' +
                        '\n' +
                        'lastname = Mc Donald\n' +
                        'Без одинарных кавычек MySQL не сможет понять этот фильтр, потому что он будет думать – нужно ли искать только по Mc или нужно искать по Mc Donald. А если все это объединить в одинарные кавычки, то фильтр станет корректным.\n' +
                        '\n' +
                        'lastname = \'Mc Donald\'\n' +
                        'Если символы, которыми мы окружаем имена объектов являются НЕ обязательными, то одинарные кавычки являются обязательными и их опускать НЕЛЬЗЯ.\n' +
                        '\n' +
                        'Итак, полный запрос, который все записи людей с фамилией Doe будет выглядеть так:\n' +
                        '\n' +
                        'SELECT * FROM phone WHERE lastname = \'Doe\'; \n' +
                        'В результате вы должны увидеть только две строки:\n' +
                        '\n' +
                        '+---------+-----------+----------+---------+--------+\n' +
                        '| phoneid | firstname | lastname | phone   | cityid |\n' +
                        '+---------+-----------+----------+---------+--------+\n' +
                        '|       1 | John      | Doe      | 4144122 |      1 |\n' +
                        '|       2 | Steve     | Doe      | 414124  |      1 |\n' +
                        '+---------+-----------+----------+---------+--------+\n' +
                        '2 rows in set (0.01 sec)\n' +
                        'В большом городе может оказаться слишком много людей с фамилией Doe и когда мы ищем телефон, то скорей всего мы знаем, что нужного нам человека зовут Steve. Мы можем искать сразу по двум колонкам – имени и фамилии, просто объединив обе проверки с помощью слова AND:\n' +
                        '\n' +
                        'SELECT * FROM phone WHERE lastname = \'Doe\' AND firstname = \'Steve\'; \n' +
                        'В ответ должна быть отображена только одна строка:\n' +
                        '\n' +
                        '+---------+-----------+----------+--------+--------+\n' +
                        '| phoneid | firstname | lastname | phone  | cityid |\n' +
                        '+---------+-----------+----------+--------+--------+\n' +
                        '|       2 | Steve     | Doe      | 414124 |      1 |\n' +
                        '+---------+-----------+----------+--------+--------+\n' +
                        '1 row in set (0.00 sec)\n' +
                        'Взглянем по-другому – мы ищем по фамилии и хотим увидеть всех, чья фамилия Doe или Jackson. Просто возможно человек поменял фамилию, и мы не знаем, под какой из них остался зарегистрирован телефон. Нам нужна записи, где колонка lastname равна Doe или Jackson. Именно так мы и должны писать наш запрос, объединив две проверки с помощью ИЛИ, в английском это OR:\n' +
                        '\n' +
                        'SELECT * FROM phone WHERE lastname = \'Doe\' OR lastname = \'Jackson\'; \n' +
                        'Результат\n' +
                        '\n' +
                        '+---------+-----------+----------+-----------+--------+\n' +
                        '| phoneid | firstname | lastname | phone     | cityid |\n' +
                        '+---------+-----------+----------+-----------+--------+\n' +
                        '|       1 | John      | Doe      | 4144122   |      1 |\n' +
                        '|       2 | Steve     | Doe      | 414124    |      1 |\n' +
                        '|       6 | Michael   | Jackson  | 4142544   |      3 |\n' +
                        '|       8 | Andre     | Jackson  | 414254422 |      3 |\n' +
                        '+---------+-----------+----------+-----------+--------+\n' +
                        '4 rows in set (0.00 sec)\n' +
                        'Ok, фамилии меняют после свадьбы и хотя у меня в таблице все имена мужские (я только сейчас сообразил и это сделано не специально), допустим, что мы знаем имя и это Andre. Возможно вы захотите написать запрос так:\n' +
                        '\n' +
                        'SELECT * \n' +
                        'FROM phone \n' +
                        'WHERE lastname = \'Doe\' OR \n' +
                        '   lastname = \'Jackson\' AND \n' +
                        '   firstname = \'Andre\';\n' +
                        'Может показаться, что в результате должна быть только одна запись – Andre Jackson, но это не так, мы увидим три записи:\n' +
                        '\n' +
                        '+---------+-----------+----------+-----------+--------+\n' +
                        '| phoneid | firstname | lastname | phone     | cityid |\n' +
                        '+---------+-----------+----------+-----------+--------+\n' +
                        '|       1 | John      | Doe      | 4144122   |      1 |\n' +
                        '|       2 | Steve     | Doe      | 414124    |      1 |\n' +
                        '|       8 | Andre     | Jackson  | 414254422 |      3 |\n' +
                        '+---------+-----------+----------+-----------+--------+\n' +
                        '3 rows in set (0.00 sec)\n' +
                        'Дело в том, что наш запрос говорит, что мы хотим увидеть всех с фамилией Doe ИЛИ всех с фамилией Jackson и именем Andre. Чтобы проще было понять проблему я добавлю скобки, чтобы показать, как сгруппированы проверки:\n' +
                        '\n' +
                        'lastname = \'Doe\' \n' +
                        'OR \n' +
                        '(lastname = \'Jackson\' AND firstname = \'Andre\')\n' +
                        'Как раз скобки мы и должны использовать, чтобы исправить проблему:\n' +
                        '\n' +
                        '(lastname = \'Doe\' OR lastname = \'Jackson\')\n' +
                        'AND \n' +
                        'firstname = \'Andre\'\n' +
                        'Здесь мы уже говорим, что у человека может быть фамилия Doe или Jackson, но имя обязательно должно быть Andre.\n' +
                        '\n' +
                        'Вот теперь мы увидим в результате только одну запись:\n' +
                        '\n' +
                        '+---------+-----------+----------+-----------+--------+\n' +
                        '| phoneid | firstname | lastname | phone     | cityid |\n' +
                        '+---------+-----------+----------+-----------+--------+\n' +
                        '|       8 | Andre     | Jackson  | 414254422 |      3 |\n' +
                        '+---------+-----------+----------+-----------+--------+\n' +
                        '1 row in set (0.00 sec)\n' +
                        'Для подобных задач в SQL есть более красивый синтаксис – использовать слово IN, что можно перевести как одно из. Формат такой:\n' +
                        '\n' +
                        'Колонка in (значения, перечисленные через запятую)\n' +
                        '\n' +
                        'То есть запрос, где мы искали одну из двух фамилий, можно переписать так:\n' +
                        '\n' +
                        'SELECT * FROM phone WHERE lastname IN (\'Doe\', \'Jackson\'); \n' +
                        'На мой взгляд это читается на много проще. Если прочитать это предложение по-русски, то все будет звучать так:\n' +
                        '\n' +
                        'ВЫБРАТЬ все ИЗ телефоны ГДЕ фамилия ОДНА ИЗ (\'Doe\', \'Jackson\')\n' +
                        'На мой взгляд наглядно. Если добавить еще и условие с именем, то запрос будет выглядеть так:\n' +
                        '\n' +
                        'SELECT * \n' +
                        'FROM phone \n' +
                        'WHERE lastname IN (\'Doe\', \'Jackson\') AND firstname = \'Andre\';\n' +
                        'Тоже достаточно просто читается и не нужно заморачиваться со скобками, чтобы указать на приоритет, как мы объединяем ИЛИ и И.\n' +
                        '\n' +
                        'Когда мы ищем по числам, то их оборачивать в одинарные кавычки не нужно. Допустим, что мы хотим найти запись в справочнике под номером 1. Именно под номером, а не первую под счету. Такой запрос может выглядеть так:\n' +
                        '\n' +
                        'SELECT * FROM phone WHERE phoneid = 1\n' +
                        'В случае с числами еще очень часто может потребоваться искать числа больше или меньше какого-то значения. Допустим, что нужно найти все записи, где id телефона меньше 5. В нашем случае это будет первые 4 строки. Как и в математике, так и в программировании можно использовать символы:\n' +
                        '\n' +
                        '< меньше\n' +
                        '> больше\n' +
                        '>= больше или равно\n' +
                        'В нашем случае можно использовать < 5 как в следующем примере:\n' +
                        '\n' +
                        'SELECT * FROM phone WHERE phoneid < 5\n' +
                        'Результат:\n' +
                        '\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '| phoneid | firstname | lastname  | phone     | cityid |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '|       1 | John      | Doe       | 4144122   |      1 |\n' +
                        '|       2 | Steve     | Doe       | 414124    |      1 |\n' +
                        '|       3 | Johnatan  | Something | 4142947   |      2 |\n' +
                        '|       4 | Donald    | Trump     | 414251123 |      2 |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        'Если мы хотим включить в выборку и строку с phoneid равных 5, то можно увеличить число до 6 или использовать меньше или равно <=\n' +
                        '\n' +
                        'SELECT * FROM phone WHERE phoneid\n' +
                        'Результат:\n' +
                        '\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '| phoneid | firstname | lastname  | phone     | cityid |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '|       1 | John      | Doe       | 4144122   |      1 |\n' +
                        '|       2 | Steve     | Doe       | 414124    |      1 |\n' +
                        '|       3 | Johnatan  | Something | 4142947   |      2 |\n' +
                        '|       4 | Donald    | Trump     | 414251123 |      2 |\n' +
                        '|       5 | Alice     | Cooper    | 414254234 |      2 |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        'Усложняем задачу, ищем записи с id больше 3 и меньше 7. И снова мы можем воспользоваться AND, чтобы объединить две проверки:\n' +
                        '\n' +
                        'SELECT * FROM phone WHERE phoneid > 3 and phoneid < 7\n' +
                        'Чтобы проще читать и красивее все выглядело можно то же самое записать:\n' +
                        '\n' +
                        'SELECT * FROM phone WHERE 3 < phoneid and phoneid < 7\n' +
                        'Для этой задачи есть вариант решения проще, по крайней мере для некоторых – использовать between:\n' +
                        '\n' +
                        'SELECT * FROM phone WHERE phoneid between 4 and 6;\n' +
                        'Обратите внимание, что я использую числа 4 и 6, а не 3 и 7, потому что between включает граничные значение, это то же самое, что и:\n' +
                        '\n' +
                        'SELECT * FROM phone WHERE phoneid >= 4 and phoneid\n' +
                        'С точки зрения чтения это звучит лучше: выбрать все из телефонов, где id между 4 и 6. Звучит хорошо, но я почему-то почти не использую эту конструкцию. Мне больше нравится решать то же самое с помощью математических конструкций > или\n' +
                        '\n' +
                        'Если работать со строками, то тут SQL предоставляет нам некую гибкость, мы можем искать по шаблону. Допустим, что мы хотим найти всех, у кого имя начинается с буквы J. Для этого используем новое слово LIKE. В английском это слово очень часто можно перевести как “нравиться” или “выглядеть как”, в зависимости от того, в качестве какой части речи использовать это слово. В данном случае это второй вариант. После этого мы можем использовать в качестве шаблона специальные символы:\n' +
                        '\n' +
                        '% заменяет любое количество любых символов\n' +
                        '\n' +
                        '_ заменяет один, но любой символ\n' +
                        '\n' +
                        'Так как нам нужно найти всех, у кого первая бука J, а потом идет любое количество любых символов, то наш шаблон будет выглядеть как \'J%\'\n' +
                        '\n' +
                        'SELECT * FROM phone WHERE firstname LIKE \'J%\'\n' +
                        'Результат:\n' +
                        '\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '| phoneid | firstname | lastname  | phone     | cityid |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '|       1 | John      | Doe       | 4144122   |      1 |\n' +
                        '|       3 | Johnatan  | Something | 4142947   |      2 |\n' +
                        '|       7 | John      | Abama     | 414254422 |      3 |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '3 rows in set (0.00 sec)\n' +
                        'А что если мы хотим найти любую фамилию, в которой содержится хотя бы одна буква A. Для этого можно указать % перед и после буквы A:\n' +
                        '\n' +
                        'SELECT * FROM phone WHERE lastname LIKE \'%a%\'\n' +
                        'Символ % означает любое количество любых символов, значит до и после A может быть что угодно и в любом количестве.\n' +
                        '\n' +
                        'Отлично, но что, если мы не знаем только одну букву. Например, моя фамилия Флёнов, но очень часто приходиться писать Фленов только потому, что буква ё не поддерживается. Очень часто это проблема печати – в паспорте, в бумажном журнале или в книге.\n' +
                        '\n' +
                        'SELECT * FROM phone WHERE lastname LIKE \'Фл_нов’\n' +
                        'Подчеркивание означает один и только один символ. Недостаток именно этого запроса – он возвращает не только Фленов и Флёнов, но, возможно, и какие-то другие вариации, если они существуют Фланов, Флонов и т.д. Но возможно именно это нам и нужно.\n' +
                        '\n' +
                        'Пустые поля NULL\n' +
                        'Если выбрать все содержимое таблицы phone, то в последних двух строках будет не число, а какое странное NULL:\n' +
                        '\n' +
                        'SELECT * FROM phone;\n' +
                        'Результат\n' +
                        '\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '| phoneid | firstname | lastname  | phone     | cityid |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '|       1 | John      | Doe       | 4144122   |      1 |\n' +
                        '|       2 | Steve     | Doe       | 414124    |      1 |\n' +
                        '|       3 | Johnatan  | Something | 4142947   |      2 |\n' +
                        '|       4 | Donald    | Trump     | 414251123 |      2 |\n' +
                        '|       5 | Alice     | Cooper    | 414254234 |      2 |\n' +
                        '|       6 | Michael   | Jackson   | 4142544   |      3 |\n' +
                        '|       7 | John      | Abama     | 414254422 |      3 |\n' +
                        '|       8 | Andre     | Jackson   | 414254422 |      3 |\n' +
                        '|       9 | Mark      | Oh        | 414254422 |   NULL |\n' +
                        '|      10 | Charly    | Lownoise  | 414254422 |   NULL |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        'NULL – это не строка и не число, это отсутствующее значение, то есть в этих двух строках в колонке cityid отсутствует. NULL можно перевести как ноль, но правильнее все же переводить это слово как “несуществующий” или “недействительный”.\n' +
                        '\n' +
                        'Если поле с числом равно 0, то это число, просто оно нулевое. А если поле с числом равно NULL, то это уже не число и не ноль, это значит, что там вообще числа нет, черная дыра, пробоина, все что угодно, но только не число.\n' +
                        '\n' +
                        'Я только что ляпнул новое понятие – поле. Это пересечение колонки и строки. Это то, куда мы записываем значение какой-то колонки/строки.\n' +
                        '\n' +
                        'Особенно такие вещи могут путать в случае работы со строками. Некоторые программы для работы с запросами отображают пустую строку и отсутствующее значение как просто пустоту. Но это не так. Просто в обоих случаях отобразить нечего.\n' +
                        '\n' +
                        'Для базы данных есть огромная разница – мы храним пустую строку или в поле нет вовсе значения, потому что это разные вещи. Если строка пустая, то это все же строка, просто у нее нет длины, но если значения нет, то строки не существует.\n' +
                        '\n' +
                        'Скорость у машины может быть нулевая, если машина стоит или какое-то число, если машина едет. А если машины нет? Скорости тоже не будет в принципе, и мы не можем сказать, что скорость нулевая у машины, которой просто нет.\n' +
                        '\n' +
                        'Работа с нулевыми полями отличается, потому что если попробовать выполнить запрос:\n' +
                        '\n' +
                        'select * from phone where cityid = null;\n' +
                        'то ничего не вернется. Казалось бы, мы же сравниваем число символом сравнения с NULL, но это не работает. Дело в том, что сравнивать с помощью равенства нельзя, вместо этого нужно использовать слово is:\n' +
                        '\n' +
                        'select * from phone where cityid is null;\n' +
                        'А если мы хотим найти все строки, в которых поле не пустое, а имеет какое-то значение. Тут нужно использовать is not:\n' +
                        '\n' +
                        'select * from phone where cityid is not null;\n' +
                        'На этом пока с основами получения данных закончим. В процессе рассмотрения дальнейшего материала мы познакомимся с еще более сложными запросами на практике.\n' +
                        '\n' +
                        'Сортировка данных в запросах SQL\n' +
                        'Когда мы выполняем запрос, то база данных может вернуть данные в любой последовательности, хотя чаще всего возвращает строки в том порядке, в котором они хранятся и чаще всего это будет совпадать со значением ключевой колонки, в нашем случае это phoneid.\n' +
                        '\n' +
                        'Если вы хотите отсортировать по фамилии, то мы должны это явно сказать серверу. Для этого используется ORDER BY, который ставиться в конце запроса:\n' +
                        '\n' +
                        'select * from phone order by lastname;\n' +
                        'Результат\n' +
                        '\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '| phoneid | firstname | lastname  | phone     | cityid |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '|       7 | John      | Abama     | 414254422 |      3 |\n' +
                        '|       5 | Alice     | Cooper    | 414254234 |      2 |\n' +
                        '|       1 | John      | Doe       | 4144122   |      1 |\n' +
                        '|       2 | Steve     | Doe       | 414124    |      1 |\n' +
                        '|       6 | Michael   | Jackson   | 4142544   |      3 |\n' +
                        '|       8 | Andre     | Jackson   | 414254422 |      3 |\n' +
                        '|      10 | Charly    | Lownoise  | 414254422 |   NULL |\n' +
                        '|       9 | Mark      | Oh        | 414254422 |   NULL |\n' +
                        '|       3 | Johnatan  | Something | 4142947   |      2 |\n' +
                        '|       4 | Donald    | Trump     | 414251123 |      2 |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        'Обратите внимание, что первая колонка теперь не отсортирована, а вот в lastname все значения возрастают начиная с буквы A в сторону Z. Нет, это происходит не всегда. Если мы не указали направление сортировки, то используется ASC, возрастание, то есть это то же самое, что написать:\n' +
                        '\n' +
                        'select * from phone order by lastname asc;\n' +
                        'А теперь посмотрите на колонку имени – оно не по возрастающей. Мы попросили отсортировать по фамилии, а когда фамилия одинаковая, то сервер имеет право вернуть данные в любом порядке и в данном случае ему удобно вывести в соответствии с ключевой колонкой phoneid. У Michael Jackson первая колонка равна 6 и это меньше 8, что мы видим у Andre.\n' +
                        '\n' +
                        'Если вы хотите, чтобы в случае одинаковой фамилии данные сортировались по имени, то нужно указать обе колонки именно в таком порядке:\n' +
                        '\n' +
                        'select * from phone order by lastname asc, firstname asc;\n' +
                        'следующий запрос вернет то же самое, потому что не забываем, что ASC – возрастание это сортировка по умолчанию:\n' +
                        '\n' +
                        'select * from phone order by lastname, firstname;\n' +
                        'Теперь данные будут сначала отсортированы по фамилии и если фамилия одинакова, то по имени и в обоих случаях по возрастающей.\n' +
                        '\n' +
                        'Можно сортировать по любому количеству колонок, если это реально принесет выгоду.\n' +
                        '\n' +
                        'Если вы хотите отсортировать таблицу по фамилии, но в обратном порядке, то вместо ASC нужно указать DESC – убывание:\n' +
                        '\n' +
                        'select * from phone order by lastname desc;\n' +
                        'Результат:\n' +
                        '\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '| phoneid | firstname | lastname  | phone     | cityid |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '|       4 | Donald    | Trump     | 414251123 |      2 |\n' +
                        '|       3 | Johnatan  | Something | 4142947   |      2 |\n' +
                        '|       9 | Mark      | Oh        | 414254422 |   NULL |\n' +
                        '|      10 | Charly    | Lownoise  | 414254422 |   NULL |\n' +
                        '|       6 | Michael   | Jackson   | 4142544   |      3 |\n' +
                        '|       8 | Andre     | Jackson   | 414254422 |      3 |\n' +
                        '|       1 | John      | Doe       | 4144122   |      1 |\n' +
                        '|       2 | Steve     | Doe       | 414124    |      1 |\n' +
                        '|       5 | Alice     | Cooper    | 414254234 |      2 |\n' +
                        '|       7 | John      | Abama     | 414254422 |      3 |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        'Добавить запись в таблицу\n' +
                        'Мы разобрались с базовыми возможностями выборки данных и сегодня давайте посмотрим, как можно добавлять новые данные. Самый простой формат вставки данных в базу данных наверно\n' +
                        '\n' +
                        'INSERT имя таблицы VALUES (значения колонок)\n' +
                        'С именем таблицы вопросов нет. Если мы хотим вставить значения в таблицу телефонов, то пишем:\n' +
                        '\n' +
                        'INSERT phone VALUES (значения колонок)\n' +
                        'При такой команде в скобках нужно обязательно указать значения для каждой колонки. Строковые значения должны быть в одинарных кавычках, числовые могут быть в кавычках, но лучше все же без них. Это уже более глубокий вопрос, который мы скорей всего рассмотрим чуть позже.\n' +
                        '\n' +
                        'Мы пока типы полей не рассматривали, но в некоторые колонки вставлять данные нельзя. К таким относится ключевое поле, если оно настроено как авто увеличиваемое. Некоторые базы позволяют изменять даже автоматически увеличиваемые поля, но даже в этом случае это не очень хорошо.\n' +
                        '\n' +
                        'MySQL относится как раз к тем базам, которые могут позволить вставлять даже в автоматические поля, хотя повторюсь, я это не рекомендую. Первое поле в обеих таблицах, которые я создал для примеров этой работы как раз является автоматически увеличиваемым и ключом. Об этом подробнее во время создания таблиц, а сейчас просто для общего развития такой небольшой отступ от основной темы.\n' +
                        '\n' +
                        'Итак, мы должны перечислить значения всех колонок, а их у нас в таблице 5, из которых первое и последние числа, значит их указываем без кавычек и указываем именно число. Первое поле ключ и его значение указывать не обязательно, но если вы сделаете это, то обязательно укажите уникальное число, которого до сих пор не было. Я создал таблицу с 10 строками, и первая колонка содержит значения от 1 до 10. Следующее значение 11, поэтому можно указать его.\n' +
                        '\n' +
                        'Итак, запрос на вставку записи с ID равным 11 будет выглядеть так:\n' +
                        '\n' +
                        'INSERT phone VALUES (11, \'Anna\', \'Koko\', \'41213213\', 1);\n' +
                        'Как я уже сказал, я сделал первую колонку автоматически увеличиваемой, поэтому значение для нее указывать не обязательно. Если вы не хотите самостоятельно искать следующее свободное число, просто не указывайте его, а вместо числа можно использовать NULL, как мы помним это как бы отсутствующее значение:\n' +
                        '\n' +
                        'INSERT phone VALUES (null, \'Elen\', \'Rokoko\', \'41213183\', 1);\n' +
                        'Если мы показываем, что для первой колонки передано NULL, то есть мы не хотим указывать значение, то для автоматически увеличиваемых полей сервер сам найдет следующее свободное и будет использовать его. В нашем случае должно быть 12. Проверим:\n' +
                        '\n' +
                        'mysql> select * from phone;\n' +
                        'Результат:\n' +
                        '\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '| phoneid | firstname | lastname  | phone     | cityid |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '|       1 | John      | Doe       | 4144122   |      1 |\n' +
                        '|       2 | Steve     | Doe       | 414124    |      1 |\n' +
                        '|       3 | Johnatan  | Something | 4142947   |      2 |\n' +
                        '|       4 | Donald    | Trump     | 414251123 |      2 |\n' +
                        '|       5 | Alice     | Cooper    | 414254234 |      2 |\n' +
                        '|       6 | Michael   | Jackson   | 4142544   |      3 |\n' +
                        '|       7 | John      | Abama     | 414254422 |      3 |\n' +
                        '|       8 | Andre     | Jackson   | 414254422 |      3 |\n' +
                        '|       9 | Mark      | Oh        | 414254422 |   NULL |\n' +
                        '|      10 | Charly    | Lownoise  | 414254422 |   NULL |\n' +
                        '|      11 | Anna      | Koko      | 41213213  |      1 |\n' +
                        '|      12 | Elen      | Rokoko    | 41213183  |      1 |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '12 rows in set (0.00 sec)\n' +
                        'Поля таблиц могут быть настроены так, что они будут обязательными и нет. Я для этого примера намеренно сделал все поля необязательными, а значит мы можем просто передать вместо значений для каждой колонки только NULL:\n' +
                        '\n' +
                        'INSERT phone VALUES (null, null, null, null, null);\n' +
                        'Проверим результат:\n' +
                        '\n' +
                        'SELECT * FROM phone WHERE phoneid = 13;\n' +
                        '\n' +
                        'И вот что, что мы получили\n' +
                        '\n' +
                        '+---------+-----------+----------+-------+--------+\n' +
                        '| phoneid | firstname | lastname | phone | cityid |\n' +
                        '+---------+-----------+----------+-------+--------+\n' +
                        '|      13 | NULL      | NULL     | NULL  |   NULL |\n' +
                        '+---------+-----------+----------+-------+--------+\n' +
                        '1 row in set (0.04 sec)\n' +
                        'Указывать отсутствующее значение (NULL) для всех колонок, для которых мы не хотим указывать реальное значение – странно и глупо. Вместо этого после имени таблицы в скобках можно указать имена колонок, значения которых мы хотим указать:\n' +
                        '\n' +
                        'INSERT phone (phoneid, phone, firstname) VALUES (14, \'4184719\', \'Mary\');\n' +
                        '\n' +
                        'В этом запросе после имени таблицы в скобках указаны имена колонок phoneid, phone и firstname. Я намеренно указал имена не в том порядке, как они созданы в таблице, ведь реально имя находиться в таблице вторым, а здесь третьим.\n' +
                        '\n' +
                        'Именно в таком же порядке должны быть предоставлены значения в круглых скобках после слова VALUES. Как видите значения тоже идут в таком же порядке – ID, номер телефона и только потом имя.\n' +
                        '\n' +
                        'Таким образом мы можем опускать любые необязательные поля, но только необязательные. Если колонка обязательно должна иметь значение, то мы обязаны указать ее в операторе INSERT и предоставить значение.\n' +
                        '\n' +
                        'У нас необязательных значений нет, так что теоретически мы можем выполнить такую команду:\n' +
                        '\n' +
                        'INSERT phone () VALUES ();\n' +
                        'Будет вставлена новая строка, у которой будут заданы только колонки, для которых есть значения по умолчанию или автоматически увеличиваемые. Эта команда идентична уже той, что мы выполняли:\n' +
                        '\n' +
                        'INSERT phone VALUES (null, null, null, null, null);\n' +
                        'Она выполниться успешно только если в таблице нет колонок с обязательными полями без значения по умолчанию.\n' +
                        '\n' +
                        'SQL - Обновление данных\n' +
                        'Бывают такие случаи, когда данные вставил в таблицу и они больше никогда не меняются. Но в реальной жизни нередко данные подвержены изменениям и у нас должна быть возможность сделать это.\n' +
                        '\n' +
                        'Минимальная команда изменения данных:\n' +
                        '\n' +
                        'UPDATE таблица\n' +
                        'SET колонка1 = значение, колонка2 = значение . . .\n' +
                        'WHERE фильтр\n' +
                        'В секции WHERE мы можем писать такие же условия, как мы делали и при SELECT. В остальном в принципе все понятно.\n' +
                        '\n' +
                        'Давайте посмотрим на содержимое строки с ID = 14:\n' +
                        '\n' +
                        'SELECT * FROM phone WHERE phoneid = 14;\n' +
                        'Результат:\n' +
                        '\n' +
                        '+---------+-----------+----------+---------+--------+\n' +
                        '| phoneid | firstname | lastname | phone   | cityid |\n' +
                        '+---------+-----------+----------+---------+--------+\n' +
                        '|      14 | Mary      | NULL     | 4184719 |   NULL |\n' +
                        '+---------+-----------+----------+---------+--------+\n' +
                        '1 row in set (0.00 sec)\n' +
                        'Здесь у нас Мэри, но у нее не было указано фамилии. Давайте обновим эту строку и укажим фамилию.\n' +
                        '\n' +
                        'UPDATE phone\n' +
                        'SET lastname = \'Poppins\'\n' +
                        'WHERE \n' +
                        'Стоп, что указать в качестве фильтра WHERE? Можно указать имя, но если в базе данных будет несколько записей людей с именем Mary, то мы обновим их все. Не думаю, что мы этого хотим.\n' +
                        '\n' +
                        'По номеру телефона. . . Возможно это сработает, если номер действительно уникальный.\n' +
                        '\n' +
                        'Если у нас есть колонка с уникальными значениями, то лучше использовать ее, тогда мы точно будем знать, что обновлена именно нужная нам запись. Именно поэтому создают в базах данных ключевые поля, как я это сделал с phoneid и самый простой способ добиться уникальности – сделать колонку автоматически увеличиваемой или сохранять в ней что-то типа уникального GUID.\n' +
                        '\n' +
                        'Некоторые базы данных даже не позволяют обновлять данные в таблице, если в ней нет уникальной колонки, потому что база данных в таком случае не может гарантировать, что будет обновлена или удалена именно нужная колонка.\n' +
                        '\n' +
                        'Если забыть про наличие phoneid, которую я заведомо и продуманно создал, то мы можем вставить в таблицу две записи с абсолютно одинаковыми значениями. Допустим, что у нас есть такая таблица:\n' +
                        '\n' +
                        '+-----------+-----------+-----------+\n' +
                        '| firstname | lastname  | cityid    |\n' +
                        '+-----------+-----------+-----------+\n' +
                        '| Mary      | NULL      | 4184719   |\n' +
                        '| Mary      | NULL      | 4184719   |\n' +
                        '| NULL      | NULL      | NULL      |\n' +
                        '+-----------+-----------+-----------+\n' +
                        'Как мы можем обновить вторую запись Mary, без уникального кода id? А первую? Да все равно какую из них! Записи идентичны и с обновлением проблема. Самый простой способ – удалить обе записи и вставить новые. Да, это решит проблему, но все же.\n' +
                        '\n' +
                        'Именно поэтому некоторые не разрешают изменять данные, если нет первичного ключа, который гарантирует уникальность данных, потому что хотя бы этот ключ и будет различать записи.\n' +
                        '\n' +
                        'С другой стороны, при наличии первичного уникального ключа, которым является personid, желательно использовать его:\n' +
                        '\n' +
                        'UPDATE phone\n' +
                        'SET lastname = \'Poppins\'\n' +
                        'WHERE personid = 14\n' +
                        'Если ты потерялся и все еще не понимаешь, что такое первичный ключ, мы еще будем говорить на тему ключей, когда будем создавать таблицы. Я помню мне тоже на первом этапе знакомства с базами данных было не совсем понятно было что это такое, зачем это нужно. Пока просто помните, что первичный ключ, это колонка (может и не одна), которая гарантирует уникальность каждой строки.\n' +
                        '\n' +
                        'Мы можем обновлять не одну, а сразу несколько колонок, указав их значения через запятую. Давайте изменим сразу фамилию и телефон:\n' +
                        '\n' +
                        'UPDATE phone\n' +
                        'SET lastname = \'Poppins\',\n' +
                        '    phone = \'48171738\'\n' +
                        'WHERE personid = 14\n' +
                        'Удаление данных из базы данных\n' +
                        'Самая простая тема – это удаление данных. Самый простой вариант удалить данные – выполнить оператор:\n' +
                        '\n' +
                        'DELETE FROM имятаблицы\n' +
                        'Что удалиться? Все!\n' +
                        '\n' +
                        'Если мы не хотим удалять все, то мы можем добавить уже знакомую нам секцию WHERE:\n' +
                        '\n' +
                        'DELETE FROM phone\n' +
                        'WHERE firstname = \'Mary\'\n' +
                        'Здесь мы удаляем все записи, где телефон принадлежит человеку с именем Mary. Если их больше одного, то будут удалены все.\n' +
                        '\n' +
                        'Если нужно удалить только конкретную запись, то мы снова можем использовать первичный ключ:\n' +
                        '\n' +
                        'DELETE FROM phone\n' +
                        'WHERE phoneid = 14\n' +
                        'В этом примере мы удалим запись, где id телефона равен 14.' }
            ]
        },
        {
            chapterNumber: 6,
            progress: 50,
            pages: [
                {progress: 60, pageNumber: 6,description: 'SQL углубимся', content: 'Продолжим знакомиться с SQL. Здесь я собрал некоторые возможности языка, которые я не стал включать в базовый SQL и оставил на будущее.\n' +
                        '\n' +
                        'сортировка по номеру колонки\n' +
                        'Для сортировки мы раньше использовали имена колонок и это в принципе работает и очень даже наглядно, но иногда бывает удобно просто сказать номер колонки – первая, вторая или любая другая. Это можно делать, просто вместо имени колонки в order by указываем порядковый номер колонки:\n' +
                        '\n' +
                        'select * from phone order by 2;\n' +
                        'Я иногда использую это в своих тестах или когда просто нужно выполнить запрос, но при программировании в коде я чаще все же использую нормальные имена. Порядковый номер не самое надежное решение.\n' +
                        '\n' +
                        'limit\n' +
                        'В таблице может находиться сразу миллионы записей и если выполнить команду\n' +
                        '\n' +
                        'SELECT * FROM phone\n' +
                        'то в результате просто чтение всех записей займет очень много времени. Если каждая запись занимает 100 байт (это не так много), и мы будем вытаскивать миллион таких записей, то придется скопировать с сервера примерно 100 мегабайт. Примерно, потому что в мегабайте чуть больше миллиона.\n' +
                        '\n' +
                        'Мы можем ограничить количество записей с помощью слова limit, после которого можно указать количество записей:\n' +
                        '\n' +
                        'SELECT * FROM phone LIMIT 5;\n' +
                        'В данном случае я попросил ограничить результат 5-ю записями. Результат такой:\n' +
                        '\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '| phoneid | firstname | lastname  | phone     | cityid |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '|       1 | John      | Doe       | 4144122   |      1 |\n' +
                        '|       2 | Steve     | Doe       | 414124    |      1 |\n' +
                        '|       3 | Johnatan  | Something | 4142947   |      2 |\n' +
                        '|       4 | Donald    | Trump     | 414251123 |      2 |\n' +
                        '|       5 | Alice     | Cooper    | 414254234 |      2 |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        'Если limit указать два числа, то первое число будет указывать на то, сколько записей нужно пропустить, а потом сколько отобразить. То есть чтобы отобразить пять строк, начиная с третей, мы должны указать 2 и 5 – пропустить 2 и потом отобразить 5:\n' +
                        '\n' +
                        'select * from phone limit 2, 5;\n' +
                        'Результат:\n' +
                        '\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '| phoneid | firstname | lastname  | phone     | cityid |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '|       3 | Johnatan  | Something | 4142947   |      2 |\n' +
                        '|       4 | Donald    | Trump     | 414251123 |      2 |\n' +
                        '|       5 | Alice     | Cooper    | 414254234 |      2 |\n' +
                        '|       6 | Michael   | Jackson   | 4142544   |      3 |\n' +
                        '|       7 | John      | Abama     | 414254422 |      3 |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        'С помощью limit у меня на сайте реализованы страницы. На каждой странице у меня на блоге отображается 10 записей. Чтобы отобразить 5-ю страницу, нужно пропустить 40 строк и отобразить начиная с 41-й по 50-ю. Чтобы сделать это нужно выполнить запрос:\n' +
                        '\n' +
                        'SELECT * \n' +
                        'FROM blog \n' +
                        'LIMIT 40, 10;\n' +
                        'уникальность данных\n' +
                        'Иногда бывает удобно отображать уникальные данные. Давайте добавим в таблице две одинаковые записи:\n' +
                        '\n' +
                        'INSERT INTO phone (firstname, phonenumber) \n' +
                        'VALUES (\'Mike\', \'1492823\');\n' +
                        'Теперь посмотрим на содержимое таблицы:\n' +
                        '\n' +
                        'SELECT * FROM phone;\n' +
                        'Результат:\n' +
                        '\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '| phoneid | firstname | lastname  | phone     | cityid |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '|       1 | John      | Doe       | 4144122   |      1 |\n' +
                        '|       2 | Steve     | Doe       | 414124    |      1 |\n' +
                        '|       3 | Johnatan  | Something | 4142947   |      2 |\n' +
                        '|       4 | Donald    | Trump     | 414251123 |      2 |\n' +
                        '|       5 | Alice     | Cooper    | 414254234 |      2 |\n' +
                        '|       6 | Michael   | Jackson   | 4142544   |      3 |\n' +
                        '|       7 | John      | Abama     | 414254422 |      3 |\n' +
                        '|       8 | Andre     | Jackson   | 414254422 |      3 |\n' +
                        '|       9 | Mark      | Oh        | 414254422 |   NULL |\n' +
                        '|      10 | Charly    | Lownoise  | 414254422 |   NULL |\n' +
                        '|      12 | Mike      | NULL      | 1492823   |   NULL |\n' +
                        '|      13 | Mike      | NULL      | 1492823   |   NULL |\n' +
                        '+---------+-----------+-----------+-----------+--------+\n' +
                        '12 rows in set (0.00 sec)\n' +
                        'Две последних строки практически одинаковы и очень часто это не то, что вы хотите видеть в результате. Допустим, что мы хотим увидеть уникальные записи и избавиться от дубликатов. Для этого существует слово distinct, которое нужно добавить после SELECT, но если просто его добавить, то оно не сработает. Попробуем:\n' +
                        '\n' +
                        'SELECT DISTINCT * FROM phone;\n' +
                        'Дело в том, что уникальность ищется по всем отображаемым колонкам, а первая колонка у обоих Майков разная, поэтому от дубликата мы не избавились. А вот если перечислить только колонки имени, фамилии, телефона, то мы получим нужный результат:\n' +
                        '\n' +
                        'SELECT DISTINCT firstname, lastname, phone FROM phone;\n' +
                        'Результат:\n' +
                        '\n' +
                        '+-----------+-----------+-----------+\n' +
                        '| firstname | lastname  | phone     |\n' +
                        '+-----------+-----------+-----------+\n' +
                        '| John      | Doe       | 4144122   |\n' +
                        '| Steve     | Doe       | 414124    |\n' +
                        '| Johnatan  | Something | 4142947   |\n' +
                        '| Donald    | Trump     | 414251123 |\n' +
                        '| Alice     | Cooper    | 414254234 |\n' +
                        '| Michael   | Jackson   | 4142544   |\n' +
                        '| John      | Abama     | 414254422 |\n' +
                        '| Andre     | Jackson   | 414254422 |\n' +
                        '| Mark      | Oh        | 414254422 |\n' +
                        '| Charly    | Lownoise  | 414254422 |\n' +
                        '| Mike      | NULL      | 1492823   |\n' +
                        '+-----------+-----------+-----------+\n' +
                        '11 rows in set (0.00 sec)\n' +
                        'У нас теперь только один Mike и на одну строку меньше. А если вы хотите увидеть только уникальные имена:\n' +
                        '\n' +
                        'SELECT DISTINCT firstname phone FROM phone;\n' +
                        'Результат:\n' +
                        '\n' +
                        '+----------+\n' +
                        '| phone    |\n' +
                        '+----------+\n' +
                        '| John     |\n' +
                        '| Steve    |\n' +
                        '| Johnatan |\n' +
                        '| Donald   |\n' +
                        '| Alice    |\n' +
                        '| Michael  |\n' +
                        '| Andre    |\n' +
                        '| Mark     |\n' +
                        '| Charly   |\n' +
                        '| Mike     |\n' +
                        '+----------+\n' +
                        '10 rows in set (0.00 sec)\n' +
                        'Результат сократился еще на одну строку, потому что теперь у нас только один Mike и только один John. У Джонов разные фамилии, поэтому в прошлый раз мы видели их обоих.\n' +
                        '\n' +
                        'сложение колонок\n' +
                        'К сожалению, у меня нет хороших колонок с числами в таблице телефонов, есть только phoneid и cityid. Это идентификаторы, но они все же числа, поэтому мы можем их сложить математически с помощью + записав это как phoneid + cityid:\n' +
                        '\n' +
                        'select phoneid, CityId, phoneid + cityid from Phone;\n' +
                        'Результат\n' +
                        '\n' +
                        '+---------+--------+------------------+\n' +
                        '| phoneid | CityId | phoneid + cityid |\n' +
                        '+---------+--------+------------------+\n' +
                        '|       1 |      1 |                2 |\n' +
                        '|       2 |      1 |                3 |\n' +
                        '|       3 |      2 |                5 |\n' +
                        '|       4 |      2 |                6 |\n' +
                        '|       5 |      2 |                7 |\n' +
                        '|       6 |      3 |                9 |\n' +
                        '|       7 |      3 |               10 |\n' +
                        '|       8 |      3 |               11 |\n' +
                        '|       9 |   NULL |             NULL |\n' +
                        '|      10 |   NULL |             NULL |\n' +
                        '+---------+--------+------------------+\n' +
                        'Смысла особо в третей колонке нет, это просто числа, но результат все же виден.\n' +
                        '\n' +
                        'Вы можете выполнять и другие математические операции, такие как минус -, умножить * или разделить /.\n' +
                        '\n' +
                        'Намного интереснее было бы объединить Имя и Фамилию в одну колонку. В записимости от базы данных это можно сделать плюсом, как в математике:\n' +
                        '\n' +
                        'SELECT FirstName + \' \' + LastName \n' +
                        'FROM phone;\n' +
                        'Когда все колонки строковые, то SQL Server будет объединять строки в одну. MySQL предпочитает вместо этого функцию CONCAT(колонка1, колонка2...). В круглых скобках через запятую перечисляются колонки, которые вы захотите объединить. Тут могут быть не только колонки, но и какие-то строки, ведь чтобы объединить имя и фамилию между ними еще нужно добавить пробел concat(FirstName, \' \', LastName), здесь в скобках у CONCAT три значения – колонка FirstName, пробел, и LastName.\n' +
                        '\n' +
                        'Полный SQL запрос будет выглядеть так:\n' +
                        '\n' +
                        'SELECT concat(FirstName, \' \', LastName) \n' +
                        'FROM phone;\n' +
                        'А результат будет таким:\n' +
                        '\n' +
                        '+----------------------------------+\n' +
                        '| concat(FirstName, \' \', LastName) |\n' +
                        '+----------------------------------+\n' +
                        '| John Doe                         |\n' +
                        '| Steve Doe                        |\n' +
                        '| Johnatan Something               |\n' +
                        '| Donald Trump                     |\n' +
                        '| Alice Cooper                     |\n' +
                        '| Michael Jackson                  |\n' +
                        '| John Abama                       |\n' +
                        '| Andre Jackson                    |\n' +
                        '| Mark Oh                          |\n' +
                        '| Charly Lownoise                  |\n' +
                        '+----------------------------------+\n' +
                        'Всего одна колонка и в ней имя и фамилия разделены пробелом.\n' +
                        '\n' +
                        'псевдонимы\n' +
                        'Возможно, вы пока не ощутите всего кайфа от псевдонимов, но уже в следующей части вы увидите, что это действительно необходимо.\n' +
                        '\n' +
                        'Вы можете создавать псевдонимы для колонок. Когда мы объединили имя и фамилию в одну колонку, то была создана как бы виртуальная колонка, которой не существует в базе данных. Какое имя у этой виртуальной колонки? Его нет и поэтому в заголовке мы видим математическую операцию, которую выполняли:\n' +
                        '\n' +
                        '+----------------------------------+\n' +
                        '| concat(FirstName, \' \', LastName) |\n' +
                        '+----------------------------------+\n' +
                        'Далеко не самое лучшее имя, поэтому было бы круто иметь возможность задать своё имя и это возможно. После имени можно указать слово as и потом псевдоним, который вы хотите увидеть в заголовке колонки. Так как мы отображаем полное имя, то этой колонке можно дать псевдоним FullName:\n' +
                        '\n' +
                        'SELECT concat(FirstName, \' \', LastName) as FullName\n' +
                        'FROM phone;\n' +
                        'Две магические буквы as указывать не обязательно, но рекомендуется, просто с эстетической точки зрения красивее.\n' +
                        '\n' +
                        'Обратите внимание, что изменилось имя в заголовке:\n' +
                        '\n' +
                        '+--------------------+\n' +
                        '| FullName           |\n' +
                        '+--------------------+\n' +
                        '| John Doe           |\n' +
                        '| Steve Doe          |\n' +
                        '| Johnatan Something |\n' +
                        '| Donald Trump       |\n' +
                        '| Alice Cooper       |\n' +
                        '| Michael Jackson    |\n' +
                        '| John Abama         |\n' +
                        '| Andre Jackson      |\n' +
                        '| Mark Oh            |\n' +
                        '| Charly Lownoise    |\n' +
                        '+--------------------+\n' +
                        'Когда мы перечисляем колонки после слова SELECT, мы просто указывали имена, но если быть боле хе аккуратным, то мы должны указывать перед именем колонки имя таблицы, из которой мы хотим увидеть данные. Так что перед именем колонки мы теоретически должны были бы указывать имя таблица phone:\n' +
                        '\n' +
                        'SELECT phone.FirstName, phone.LastName \n' +
                        'FROM phone;\n' +
                        'У нас одна таблица в запросе, поэтому MySQL и любая другая база данных без проблем могут догадаться, что колонки имени и фамилии будут как раз из таблицы phone.\n' +
                        '\n' +
                        'В тех случаях (а мы их рассмотрим скоро), когда мы обязаны указать имя таблицы перед именами колонок мы можем использовать псевдонимы. После имени таблицы в секции FROM можно дать таблице phone псевдоним в виде одной буквы p, и теперь использовать псевдоним и перед именами колонок ставить именно его:\n' +
                        '\n' +
                        'SELECT p.FirstName, p.LastName \n' +
                        'FROM phone p;\n' +
                        'Одна буква – это на много проще, чем писать все имя таблицы.\n' +
                        '\n' +
                        'Всегда ли мы должны использовать именно букву P? Нет, вы можете выбирать любую букву, просто чаще всего берут именно ту, с которой начинается имя таблицы. Для таблицы городов можно было бы выбрать псевдоним – букву С, а можете любую другую.' }
            ]
        },

    ]
};